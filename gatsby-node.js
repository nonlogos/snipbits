const path = require('path');
const axios = require('axios');
const { createRemoteFileNode } = require('gatsby-source-filesystem');

// Create new pages for all mdx files using the post-template template
exports.createPages = async ({ graphql, actions, reporter }) => {
	const { createPage } = actions;

	const postsResult = await graphql(`
		query {
			allMdx {
				edges {
					node {
						id
						# Slug field added by gatsby-plugin-mdx
						slug
					}
				}
			}
		}
	`);

	if (postsResult.errors) {
		reporter.panicOnBuild('ERROR: loading createPages query');
	}

	const posts = postsResult.data.allMdx.edges;

	posts.forEach(({ node }, index) => {
		createPage({
			// The slug generated by gatsby-plugin-mdx doesn't contain a slash at the beginning
			// You can prepend it with any prefix you want
			path: `/${node.slug}`,
			// This component will wrap our MDX content
			component: path.resolve(`./src/templates/post-template.tsx`),
			// You can use the values in this context in
			// our page layout component
			context: {
				id: node.id,
			},
		});
	});

	// create index page with js-search settings for each content type
	// [TODO] see if we can add fragment here
	const indexPostsResult = await graphql(`
		query postQuery {
			blogs: allMdx(
				sort: { fields: [frontmatter___date, frontmatter___title], order: [DESC, ASC] }
				filter: { fields: { contentType: { eq: "blog" } } }
			) {
				nodes {
					id
					frontmatter {
						date(locale: "", formatString: "MM-DD-YYYY")
						title
						keywords
						description
					}
					fields {
						contentType
					}
					excerpt(pruneLength: 76)
					slug
				}
				totalCount
			}
			snippets: allMdx(
				sort: { fields: [frontmatter___date, frontmatter___title], order: [DESC, ASC] }
				filter: { fields: { contentType: { eq: "snippets" } } }
			) {
				nodes {
					id
					frontmatter {
						date(locale: "", formatString: "MM-DD-YYYY")
						title
						keywords
						description
					}
					fields {
						contentType
					}
					excerpt(pruneLength: 76)
					slug
				}
				totalCount
			}
		}
	`);

	const indexBookmarksResult = await axios.get('https://bvaughn.github.io/js-search/books.json');

	if (indexPostsResult.errors || !indexBookmarksResult.data) {
		reporter.panicOnBuild('ERROR: loading createPages query');
	}
	const bookmarks = indexBookmarksResult.data.books;
	// const allContents = { ...indexPostsResult.data, bookmarks };

	createPage({
		path: '/',
		component: path.resolve(`./src/templates/SearchResultsTemplate.tsx`),
		context: {
			bookmarkData: {
				allBookmarks: bookmarks,
				options: {
					SearchIndex: 'isbn',
					Indexes: ['title', 'author', 'isbn'],
				},
			},
			postsData: {
				allPosts: indexPostsResult.data,
				options: {
					SearchIndex: 'id',
					Indexes: [['frontmatter', 'description'], ['frontmatter', 'title'], ['frontmatter', 'keywords'], 'excerpt'],
				},
			},
		},
	});
};

exports.onCreateNode = async ({ node, createNodeId, actions: { createNodeField, createNode }, cache, store }) => {
	if (node.internal.type === 'Mdx') {
		if (node.fileAbsolutePath) {
			createNodeField({
				node,
				name: 'contentType',
				value: node.fileAbsolutePath.split('/src/posts/')[1].split('/')[0],
			});
		}

		// Asynchornously download remote images and store with new node called embeddedImagesRemote
		if (node.frontmatter && node.frontmatter.embeddedImagesRemote) {
			let embeddedImagesRemote = await Promise.all(
				node.frontmatter.embeddedImagesRemote.map((url) => {
					try {
						return createRemoteFileNode({
							url,
							parentNodeId: node.id,
							createNode,
							createNodeId,
							cache,
							store,
						});
					} catch (error) {
						console.error(error);
					}
				})
			);
			if (embeddedImagesRemote) {
				createNodeField({
					node,
					name: 'embeddedImagesRemote',
					value: embeddedImagesRemote.map((image) => {
						return image.id;
					}),
				});
			}
		}
	}
};

// in order to correctly process mdx frontmatter images using childImageSharp, GraphQL needs to understand that the field is of type File. here we use createType to manually type a new field

exports.createSchemaCustomization = ({ actions, schema }) => {
	const { createTypes } = actions;
	createTypes(`
   type Mdx implements Node {
     frontmatter: Frontmatter
     embeddedImagesRemote: [File] @link(from: "fields.embeddedImagesRemote")  
   }
   type Frontmatter @dontInfer {
     title: String!
		 date: Date @dateformat(formatString: "YYYY-MM-DD")
		 description: String
		 keywords: [String]
		 embeddedImagesLocal: [File] @fileByRelativePath
     embeddedImagesRemote: [String]
   }
 `);
};
